/**
 * used in GAS to mask the ledger sheet
 * will need to add this functionality in the managing-app
 * **/

/** CONFIG **/
const RAW_SHEET = 'ledger_raw';
const MASK_SHEET = 'ledger_masked';
const SALT_KEY = 'MASK_SALT';

// IN判定に使うキーワード（摘要/タグで検出）
const INCLUDES_KEYWORDS = ['供託金戻り', 'キャッシュバック'];

// IN時のマスク免除フレーズ（摘要の生テキストに含まれたらマスクしない）
const IN_EXEMPT_PHRASE = '振込1 TEAMMIRAI ストライフ';

function setup() {
    const props = PropertiesService.getScriptProperties();
    if (!props.getProperty(SALT_KEY)) props.setProperty(SALT_KEY, Utilities.getUuid());
    SpreadsheetApp.getUi().createMenu('Masker')
        .addItem('Rebuild masked sheet', 'rebuildMasked')
        .addToUi();
    cleanTriggers_();
    ScriptApp.newTrigger('rebuildMasked').forSpreadsheet(SpreadsheetApp.getActive().getId()).onChange().create();
    ScriptApp.newTrigger('rebuildMasked').forSpreadsheet(SpreadsheetApp.getActive().getId()).onEdit().create();
}

function cleanTriggers_() {
    for (const t of ScriptApp.getProjectTriggers()) {
        if (t.getHandlerFunction() === 'rebuildMasked') ScriptApp.deleteTrigger(t);
    }
}

function rebuildMasked() {
    const ss = SpreadsheetApp.getActive();
    const raw = ss.getSheetByName(RAW_SHEET);
    if (!raw) throw new Error(`Sheet not found: ${RAW_SHEET}`);

    const values = raw.getDataRange().getValues();
    if (values.length === 0) return;

    const header = values[0].map(h => String(h).trim());
    const col = Object.fromEntries(header.map((h, i) => [h, i]));

    const required = [
        '取引No', '取引日',
        '借方勘定科目', '借方補助科目', '借方部門', '借方取引先', '借方税区分', '借方インボイス', '借方金額(円)',
        '貸方勘定科目', '貸方補助科目', '貸方部門', '貸方取引先', '貸方税区分', '貸方インボイス', '貸方金額(円)',
        '摘要', 'タグ', 'メモ'
    ];
    required.forEach(h => { if (col[h] == null) throw new Error(`Missing header: ${h}`); });

    // 出力ヘッダ = 元ヘッダ + 摘要1..3 + 摘要_詳細 + IN/OUT
    const outHeader = header.concat(['摘要1', '摘要2', '摘要3', '摘要_詳細', 'IN/OUT']);
    const out = [outHeader];

    for (let r = 1; r < values.length; r++) {
        const src = values[r];
        const row = src.slice();

        const creditAccount = String(row[col['貸方勘定科目']] || '');
        const tag = String(row[col['タグ']] || '').trim();
        const rawSummary = String(row[col['摘要']] || ''); // 判定用の生テキスト

        // IN/OUT
        const inout = classifyInOut_(creditAccount, rawSummary, tag);

        // マスク判定（基本: 貸方勘定科目 = 寄附金）、ただしIN & 免除フレーズ含む場合はマスクしない
        let summary = rawSummary;
        let masked = false;
        const shouldMaskBase = (creditAccount === '寄附金');
        const exempt = (inout === 'IN') && includesNormalized_(rawSummary, IN_EXEMPT_PHRASE);

        if (shouldMaskBase && !exempt) {
            summary = maskText_(summary);
            row[col['摘要']] = summary; // マスクした摘要を書き戻し
            masked = true;
        }

        // 摘要の分解（マスクされていないときのみ）
        let s1 = '', s2 = '', s3 = '';
        if (!masked) [s1, s2, s3] = explodeSummary_(summary);

        // 摘要_詳細
        let detail = '';
        if (inout === 'IN') {
            // IN: マスクされていれば行番号、されてなければ "stripe"
            detail = masked ? String(r + 1) : 'stripe';
        } else {
            // OUT: 既存優先 (タグ -> 摘要3 -> 2 -> 1)
            detail = firstNonEmpty_(tag, s3, s2, s1);
        }

        out.push(row.concat([s1, s2, s3, detail, inout]));
    }

    let maskedSheet = ss.getSheetByName(MASK_SHEET);
    if (!maskedSheet) maskedSheet = ss.insertSheet(MASK_SHEET);
    maskedSheet.clearContents();
    maskedSheet.getRange(1, 1, out.length, out[0].length).setValues(out);

    maskedSheet.protect().setDescription('Auto-generated by masker').setWarningOnly(true);
    maskedSheet.getRange(2, col['借方金額(円)'] + 1, maskedSheet.getLastRow() - 1, 1).setNumberFormat('#,##0');
    maskedSheet.getRange(2, col['貸方金額(円)'] + 1, maskedSheet.getLastRow() - 1, 1).setNumberFormat('#,##0');
}

// --- Helpers ---
function maskText_(text) {
    return '***';
}

function explodeSummary_(text) {
    // 半角スペース基準。全角もまとめたい場合は /[ 　]+/g に変更
    const t = String(text || '').replace(/ +/g, ' ').trim();
    if (!t) return ['', '', ''];
    const parts = t.split(' ');
    const s1 = parts.shift() || '';
    const s2 = parts.shift() || '';
    const s3 = parts.length ? parts.join(' ') : '';
    return [s1, s2, s3];
}

function firstNonEmpty_(...vals) {
    for (const v of vals) {
        if (String(v || '').trim() !== '') return String(v).trim();
    }
    return '';
}

function classifyInOut_(creditAccount, rawSummary, tag) {
    const isDonation = creditAccount === '寄附金';
    const text = (String(rawSummary || '') + ' ' + String(tag || '')).toLowerCase();
    const hitKeyword = INCLUDES_KEYWORDS.some(k => text.indexOf(k.toLowerCase()) !== -1);
    return (isDonation || hitKeyword) ? 'IN' : 'OUT';
}

// スペース連結のゆらぎを吸収して包含判定
function includesNormalized_(text, phrase) {
    const norm = s => String(s || '').replace(/[ 　]+/g, ' ').trim();
    const t = norm(text);
    const p = norm(phrase);
    return t.indexOf(p) !== -1;
}
